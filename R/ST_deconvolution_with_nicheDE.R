#' Generate distance matrix for spatial sequencing data
#'
#' This function generates distance matrix based on coordinates of spots from spatial transcriptomics
#' data.
#' @param coord_df The dataframe containing coordinate of spots.
#' @param use_rank Logical. If true, the distance to a target spot is represented by the rank of distances for
#' all neighbor spots; else the distance is represented by Euclidean distance. Default is TRUE.
#' @examples
#' data(st_coords)
#' dist_mat<-generate_dist_mtx(coord_df = st_coords)
#' @importFrom raster pointDistance
#' @import dplyr
#' @export
generate_dist_mtx<-function(coord_df,use_rank=T){
  dist_mat<-pointDistance(coord_df, lonlat=FALSE)
  row.names(dist_mat)<-row.names(coord_df)
  colnames(dist_mat)<-row.names(coord_df)
  dist_mtx<-dist_mat
  if (use_rank==T){
    rank_mat<-round(dist_mat)
    rank_mat<-apply(rank_mat, 1, dense_rank)
    row.names(rank_mat)<-row.names(coord_df)
    dist_mtx<-rank_mat
  }

  return(dist_mtx)
}

#' Calculate abundance of neighbor cell types for spots
#'
#' This function calculate abundance of neighbor cell types for each spot based on cell proportions
#' and distance of neighbor spots.
#' @param feature_mat A matrix of cell type-specific proportions for spots.
#' @param dist_mat A matrix of spot-spot distance generated by `generate_dist_mtx()`.
#' @param spotID The spotID for the index spot from feature_mat and dist_mat.
#' @param c A constant that controls the weight of spot-spot distance during abundance calculation.
#' @param consider_self Logical. Whether considering cells in the index spot itself while calculating
#'  cell abundance for this spot.
#' @examples
#' neighbor_abundance(feature_mat = prop_estimate, dist_mat = dist_mat, spotID = row.names(prop_estimate)[1], c = 0.05)
#'
#' @export
neighbor_abundance<-function(feature_mat,dist_mat,spotID,c=0.5,consider_self=T){
  x<-dist_mat[spotID,]
  x<-x[intersect(names(x),row.names(feature_mat))]
  neighbor_ID<-names(x)
  if (consider_self==F){
    neighbor_ID<-setdiff(neighbor_ID,spotID)
    x<-x[neighbor_ID]
  }
  prop_mat<-feature_mat[neighbor_ID,]
  output_abundance<-apply(prop_mat,2,function (t) weighted.mean(t,exp(-c*x)))
  return(output_abundance)
}

#' Generate spot-specific cell expression profiles
#'
#' This function generates cell type-specific expression profile for one spot based on its neighbor
#' cell abundance, niche effects from surroundings and initial expression profile gotten by sc-level
#' data.
#' @param alpha A constant that controls the influential level of niche effects on gene expression.
#' @param spotID The spotID of the index spot to calculate spot-specific expression profile.
#' @param sig_beta_list A dataframe containing information of niche effects gotten by previous loop.
#' @param marker_ref_celltype_gep The reference cell type-specific expression profile of marker genes
#' gotten from `generate_marker_celltype_gep()`.
#' @param neighbor_prop A matrix of neighbor cell abundance gotten by `neighbor_abundance()`.
#' @export
generate_spot_exp<-function(alpha=0.2,spotID,sig_beta_list,marker_ref_celltype_gep,neighbor_prop){
  type<-colnames(marker_ref_celltype_gep)
  cellcomb<-c()
  for (i in type) {
    for (j in setdiff(type,i)) {
      cellcomb<-c(cellcomb,paste0(i,"-",j))
    }
  }
  new_marker_ref_celltype_count<-marker_ref_celltype_gep
  sig_beta_mtx<-matrix(data = 0, nrow = nrow(marker_ref_celltype_gep),ncol = length(cellcomb))
  row.names(sig_beta_mtx)<-row.names(marker_ref_celltype_gep)
  colnames(sig_beta_mtx)<-cellcomb
  for (i in (1:nrow(sig_beta_list))) {
    if (sig_beta_list$geneName[i]%in%row.names(sig_beta_mtx)){
      sig_beta_mtx[sig_beta_list$geneName[i],sig_beta_list$interaction[i]]<-sig_beta_list$coefficient[i]
    }
  }
  for (i in type) {
    data<-sig_beta_mtx[,paste0(i,"-",setdiff(type,i))]
    #data<-apply(data, 2, function(x) ifelse(x==0,0,1/x))
    data<-apply(data, 2, function(x) ifelse(x>0,1,ifelse(x<0,-1,0)))
    for (j in setdiff(type,i)) {
      data[,paste0(i,"-",j)]<-data[,paste0(i,"-",j)]*neighbor_prop[spotID,j]
    }
    niche_w<-apply(data, 1, sum)
    new_marker_ref_celltype_count[,i]<-new_marker_ref_celltype_count[,i]*(1+alpha*niche_w)
  }
  return(new_marker_ref_celltype_count)
}

#' Determine whether a cell type existing in one spot
#'
#' This function is used to determine whether a cell type exists in the spot based on the estimated
#' cell proportion and cut-off values.
#' @param prop_vec A vector of cell proportion gotten by cell type-specific deconvolution.
#' @param cutoff A threshold for cell proportion; cell type with higher proportion than the cutoff
#' exists in the spot.
#' @param cell_cut_list A vector of cut-off values for each cell type. If NULL, will use the same
#' threshold defined by cutoff.
#' @export
determine_cell_exist<-function(prop_vec,cutoff=0.1,cell_cut_list=NULL){
  cell_exist<-prop_vec
  if (is.null(cell_cut_list)==F){
    for (i in names(prop_vec)) {
      cell_exist[i]<-ifelse(prop_vec[i]>cell_cut_list[i],1,0)
    }
  } else {
    for (i in names(prop_vec)) {
      cell_exist[i]<-ifelse(prop_vec[i]>cutoff,1,0)
    }
  }

  return(cell_exist)
}

#' Perform cell type-specific deconvlution to estimate relative cell numbers for spots
#'
#' This function use Non-negative least squares regression to estimate relative numbers of each
#' cell type in the spots based on cell type-specific expression profiles.
#' @param spot_count A vector of gene expression level for one spot.
#' @param marker_ref_celltype_gep The reference cell type-specific expression profile of marker genes.
#' @param cutoff A threshold for cell proportion; cell type with higher proportion than the cutoff
#' exists in the spot.
#' @param cell_cut_list A vector of cut-off values for each cell type. If NULL, will use the same
#' threshold defined by cutoff.
#' @examples
#' # cell_cut_list=NULL
#' data(st_count)
#' nnls_output <- calculate_nnls_cut(spot_count = st_count[,1], marker_ref_celltype_gep = marker_ref_celltype_count)
#' # Set up cell_cut_list
#' cell_cut_list<-c(0.2,0.4,0.2,0.1,0.1,0.1)
#' names(cell_cut_list)<-colnames(marker_ref_celltype_count)
#' nnls_output <- calculate_nnls_cut(spot_count = st_count[,1], marker_ref_celltype_gep = marker_ref_celltype_count, cell_cut_list = cell_cut_list)
#' @import nnls
#' @export
calculate_nnls_cut<-function(spot_count,marker_ref_celltype_gep,cutoff=0.1,cell_cut_list=NULL){
  type<-colnames(marker_ref_celltype_gep)
  y<-spot_count[row.names(marker_ref_celltype_gep)]
  mod1 <- nnls(marker_ref_celltype_gep,y)
  x<-mod1$x
  x<-x/sum(x)
  names(x)<-type
  exist_vector<-x
  if (is.null(cell_cut_list)==F){
    for (i in names(x)) {
      exist_vector[i]<-ifelse(x[i]>cell_cut_list[i],1,0)
    }
  } else {
    for (i in names(x)) {
      exist_vector[i]<-ifelse(x[i]>cutoff,1,0)
    }
  }
  data0<-marker_ref_celltype_gep[,which(exist_vector==1),drop=F]
  mod1 <- nnls(data0,y)
  y<-rep(0,length(type))
  y[which(exist_vector==1)]<-mod1$x
  names(y)<-type
  return(y)
}
